;1. Implement couroutine?
;2. launch 1 thread per cpu core at program launch
    ;- each thread is passed x double ended queues (where x is the number of
      ;threads), implement a work stealing algorithm
    ;- Add couroutine to the queue with the least number of tasks (lowest queue
      ;depth, when tied, lowest numbered cpu)
    ;- When a thread has no more work it steals the task off the bottom of the
      ;largest queue 
;3. When a (go (form)) function is launched it adds the form to the bottom of
;the lowest queue (lowest numbered cpu when tied)


;This is thre real main of a 3 program, the (data main) expression is called
;via (go main) after this is setup 
#lang 3
(require ffi/unsafe
         ffi/unsafe/define)
(require racket/cmdline)
(require racket/async-channel)
(require racket/class)
(require main) ;user defined data main.3 file

;;eternal thread loop of executing tasks
(define 3-thread (thread-num channels) 
  (eval-task (get-task (thread-num channels)))  ;execute the task we get
  (3-thread (channels)))

;TODO gets task from own channel. If empty, steal task from bottom of least empty
;queue. If no task is available it blocks waiting for a task in its queue
(define get-task (thread-num channels))

;TODO evaluate a task. This will either be a standard function call OR message
;handling
(define eval-task (task))

;TODO returns number of cpus-1
(define (get-num-cpu)) 

;TODO appends func expresion to the emptiest thread channel. Expects
;*thread-channels* to be defined
(define (go func))

;TODO  
(define (make-double-ended-channel)
  (make-async-channel #f))

;;make the desired thread channels and return as a list
(define (make-channels num *thread-channels*)
  (if (> num 0)
    (make-channels (- num 1) (append *thread-channels* (list make-double-ended-channel)))))

;;setup worker threads and begin execution of the user defined main
(define start-3 (args)
  (let ([num-cpu (get-num-cpu)])
    (let ([*thread-channels* (make-channels num-cpu 0 (list))])
      (define (make-threads num *thread-channels*)
        (if (> num 0)
          (thread (3-thread num *thread-channels*))
          (make-threads (- num 1) *thread-channels*)))
      (make-threads num-cpu *thread-channels*)
      (go (main args))
      (3-thread (0 *thread-channels*)))))

;;;; 3 language definitions, in 3.rkt file or something
(define (data )) ;create a mutable data object (no function definitons allowed within a data object
(define (func )) ;define a stateless function
(define (message)) ;define a message
(define (say)) ;emit message
(define (listen )) ;listen for message
(define (channel)) ;create a channel, an extension of messages and 2 way queues
(define (:)) ;in a data object this is a (define), illegal in a func (only (let) allowed)
(define ())

;;execute 3
;TODO figure out how to get argv & argc
(start-3 (list argv argc))
