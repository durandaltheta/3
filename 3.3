;1. Implement couroutine?
;2. launch 1 thread per cpu core at program launch
    ;- each thread is passed x double ended queues (where x is the number of
      ;threads), implement a work stealing algorithm
    ;- Add couroutine to the queue with the least number of tasks (lowest queue
      ;depth, when tied, lowest numbered cpu)
    ;- When a thread has no more work it steals the task off the bottom of the
      ;largest queue 
;3. When a (go (form)) function is launched it adds the form to the bottom of
;the lowest queue (lowest numbered cpu when tied)


;This is thre real main of a 3 program, the (data main) expression is called
;via (go main) after this is setup 
#lang 3
;(require racket/cmdline)
(require racket/base)
(require ffi/unsafe/atomic) ;atomic execution of specific tasks
(require data/queue)
(require racket/async-channel)
(require pure/stateless)
(require racket/class)
(require main) ;user defined data main.3 file 


;;;----------------------------------------------------------------------------
;;;couroutine definition 
;;;----------------------------------------------------------------------------
(define (coroutine routine)
   (let ([current routine]
         (status 'suspended))
     (lambda args
       (cond ((null? args) 
              (if (eq? status 'dead)
                  (error 'dead-coroutine)
                  (let ([continuation-and-value
                         (call/cc (lambda (return)
                                    (let ([returner
                                           (lambda (value)
                                             (call/cc (lambda (next)
                                                        (return (cons next value)))))])
                                      (current returner)
                                      (set! status 'dead))))])
                    (if (pair? continuation-and-value)
                        (begin (set! current (car continuation-and-value))
                               (cdr continuation-and-value))
                        continuation-and-value))))
             ((eq? (car args) 'status?) status)
             ((eq? (car args) 'dead?) (eq? status 'dead))
             ((eq? (car args) 'alive?) (not (eq? status 'dead)))
             ((eq? (car args) 'kill!) (set! status 'dead))
             (true nil)))))

;; Coroutines are intended to be used when defining functions. Somehow 3 needs 
;; to execute all functions defined in the 3 language as couroutines that yield
;; on return. Then the thread loop would be updated with couroutine checks and 
;; special handling for routines that are taking too long (move them to back of 
;; the queue). This should help provide concurrency for tasks with long
;; execution times. 


;;;----------------------------------------------------------------------------
;;;datapool thread functions
;;;----------------------------------------------------------------------------
;;TODO gets task from own channel. If empty, steal task from top of least empty
;;queue. If no task is available it blocks waiting for a task in its queue
(defun get-max-queue (m l)
  (cond [(null? (caar l)) m]
        [(> (car l) m) (get-max (car l) (cdr l))]
        [else (get-max m (cdr l)))])

(defun get-min-queue (m l)
  (cond [(null? (caar l)) m]
        [(> (car l) m) (get-min (car l) (cdr l))]
        [else (get-min m (cdr l)))])

;; return thread's queue if not empty, otherwise steal from top of fullest 
;; sibling thread queue
(define (get-task-queue thread-num thread-queues)
  (let ([thread-queue (vector-ref thread-queues thread-num)])
    (? (eqv? (queue-length thread-queue) 0)
      (let ([highest-queue (cdr (get-max-queue (for ([i thread-queues]) 
             '((queue-length i) i))))])
           (if (eqv? highest-queue 0) 
             (thread-suspend)
             (highest-queue)))
      (thread-queue))

(define (get-task thread-num thread-queues)
  (let ([queue (get-task-queue thread-num thread-queues)])
    ())) ;TODO, need thread safe queue pop mutation

(define (dp-thread-get-queue-head queue)
  (with-handlers ([exn:fail? #f])
   (head queue)))

;;TODO evaluate a task. This will either be a standard function call OR message
;;handling
(define eval-task (task))

;;TODO appends func expresion to the emptiest thread channel.
(define (go pool func)
  (atomic-push (get-min-queue pool) (pure/stateless func)))

;;eternal thread tail recursion of executing tasks
(define dp-thread (thread-num thread-queues) 
  (eval-task (get-task (thread-num thread-queues)))  ;execute the task we get
  (dp-thread (thread-num thread-queues)))

;;make the desired thread channels and return as a list
(define (make-channels num thread-queues)
  (if (> num 0)
    (make-channels (- num 1) 
      (set! thread-queues (append thread-queues '((make-queue)))))))

(define (make-threads num threads thread-queues)
  (if (> num 0)
    (set! threads (append threads '(thread (dp-thread num thread-queues))))
    (make-threads (- num 1) thread-queues)))



;;;----------------------------------------------------------------------------
;;;basic channel functions
;;;----------------------------------------------------------------------------
;;create an async channel, no size limit by default
(define (channel [size #f]) (make-async-channel size))

;;channel get, blocks by default
(define (<- ch [block #t])
  (if block
    (async-channel-get ch)
    (async-channel-try-get ch)))

;;channel put
(define (-> ch item)
  (async-channel-put ch))



;;;----------------------------------------------------------------------------
;;;datapool functions
;;;----------------------------------------------------------------------------
;;create datapool data struct
;;if this value goes out of scope during its assigned datapool execution the 
;;program will crash
(define (make-datapool-data) '('() '() (channel #f)))

(define (datapool-data-channel datapool-data) 
  (cddr datapool-data))

(define (datapool-data-threads datapool-data)
  (car datapool-data))

;;kill all threads in a datapool
(define (close-datapool datapool-data)
  (for ([i (datapool-data-threads datapool-data)])
    (kill-thread i)))
  
;;return a message from the datapool's channel
(define (listen-datapool datapool-data block)
  (let ([ch (datapool-data-channel datapool-data)])
    (<- ch block)))
  
;;create a datapool
;;setup worker threads and begin execution of the user defined func
(define (datapool thread-data num-threads func args)
  (let ([thread-data (make-datapool-data)]
    (if (> num-threads 0)
      (begin
        (make-channels num-threads (cdr thread-data))
        (make-threads num-threads (car thread-data) (cdr thread-data))
        (go (func '(thread-data args)))))
    (thread-data)))

        

;;;----------------------------------------------------------------------------
;;; 3 language definitions, in 3.rkt file or something
;;;----------------------------------------------------------------------------
;;create a mutable data object (no function definitons (func ...) allowed within a data object
(define-syntax data
  (syntax-rules ()
    [(data ...)]
(data) ())

;;in a data object this is a (define-property)
;;illegal in a func (only (let) allowed)
(define (:) ()) 

;;define a stateless couroutine
(define-syntax func
  (syntax-rules ()
    [(func ...) (couroutine 
                  (let ([ret (pure/stateless (func ...))])
                    (yield)
                    (ret))]))

;;;----------------------------------------------------------------------------
;;; Optional 3 definitions, if channels are insufficient
;;;----------------------------------------------------------------------------
;;define a message
(define (message) ()) 

;;emit message
(define (say source message) ()) 

;;listen for message
(define (listen source message destination function) ()) 



;;execute 3
;TODO figure out how to get argv & argc 
(define (get-num-cpu) (4)) 
(define dp1 (datapool (- (get-num-cpus) 1) main '(argv argc)))
